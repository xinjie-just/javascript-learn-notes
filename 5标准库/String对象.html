<!DOCTYPE html>
<html>
<head>
<title>String对象.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="string-%E5%AF%B9%E8%B1%A1">String 对象</h1>
<p><code>String</code> 对象是 JavaScript 原生提供的三个包装对象之一，用来生成字符串对象。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">let</span> s1 = <span class="hljs-string">"abc"</span>;
<span class="hljs-keyword">let</span> s2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">"abc"</span>);

<span class="hljs-keyword">typeof</span> s1; <span class="hljs-comment">// 'string'</span>
<span class="hljs-keyword">typeof</span> s2; <span class="hljs-comment">// 'object'</span>

s2.valueOf(); <span class="hljs-comment">// 'abc'</span>
</div></code></pre>
<p>由于 <code>s2</code> 是字符串对象，<code>s2.valueOf()</code> 方法返回的就是它所对应的原始字符串。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">"abc"</span>);
<span class="hljs-comment">// String {0, "a", 1: "b", 2: "c", length: 3}</span>
<span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">"abc"</span>)[<span class="hljs-number">1</span>]; <span class="hljs-comment">// "b"</span>
</div></code></pre>
<p>除了用作构造函数创建类似数组的对象外，<code>String</code> 还可以当做工具函数使用，将任意类型的值转换为字符串。</p>
<h2 id="1-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">1. 静态方法</h2>
<h3 id="11-stringfromcharcode">1.1. String.fromCharCode()</h3>
<p><code>String</code> 对象提供的静态方法（即定义在对象本身，而不是定义在对象实例的方法），主要是 <code>String.fromCharCode()</code>。该方法的参数是一个或多个数值，代表 <code>Unicode</code> 码点，返回值是这些码点组成的字符串。</p>
<pre class="hljs"><code><div><span class="hljs-built_in">String</span>.fromCharCode(); <span class="hljs-comment">// ""</span>
<span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">97</span>); <span class="hljs-comment">// "a"</span>
<span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">104</span>, <span class="hljs-number">101</span>, <span class="hljs-number">108</span>, <span class="hljs-number">108</span>, <span class="hljs-number">111</span>);
<span class="hljs-comment">// "hello"</span>
</div></code></pre>
<p>该方法不支持 <code>Unicode</code> 码点大于 <code>0xFFFF</code> 的字符，即传入的参数不能大于 <code>0xFFFF</code>（即十进制的 65535）。</p>
<pre class="hljs"><code><div><span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">0x20bb7</span>);
<span class="hljs-comment">// "ஷ"</span>

<span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">0x20bb7</span>) === <span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">0x0bb7</span>);
<span class="hljs-comment">// true</span>
</div></code></pre>
<p>上面代码中，<code>String.fromCharCode</code> 参数 <code>0x20BB7</code> 大于 <code>0xFFFF</code>，导致返回结果出错。<code>0x20BB7</code> 对应的字符是汉字<code>𠮷</code>，但是返回结果却是另一个字符（码点 <code>0x0BB7</code>）。这是因为 <code>String.fromCharCode</code> 发现参数值大于 <code>0xFFFF</code>，就会忽略多出的位（即忽略 <code>0x20BB7</code> 里面的 2）。</p>
<h2 id="3-%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7">3. 实例属性</h2>
<h3 id="31-stringprototypelength">3.1. String.prototype.length</h3>
<pre class="hljs"><code><div><span class="hljs-string">"abc"</span>.length; <span class="hljs-comment">// 3</span>
</div></code></pre>
<h2 id="4-%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95">4. 实例方法</h2>
<h3 id="41-stringprototypecharat">4.1. String.prototype.charAt()</h3>
<p><code>charAt()</code> 方法返回某个位置的字符，位置从 0 开始。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">let</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">"abc"</span>);
s.charAt(); <span class="hljs-comment">// "a"</span>
s.charAt(<span class="hljs-number">0</span>); <span class="hljs-comment">// "a"</span>
s.charAt(<span class="hljs-number">1</span>); <span class="hljs-comment">// "b"</span>
s.charAt(s.length - <span class="hljs-number">1</span>); <span class="hljs-comment">// "c"</span>
s.charAt(<span class="hljs-number">-1</span>); <span class="hljs-comment">// ""</span>
s.charAt(<span class="hljs-number">4</span>); <span class="hljs-comment">// ""</span>
</div></code></pre>
<p>从上面代码可以看出，<code>charAt()</code> 方法：</p>
<ul>
<li>不传参数时，返回第一个字符，相当于传参 <code>0</code>。</li>
<li>传参为负数时，返回空字符串。</li>
<li>传参为一个大于字符串长度的数时，返回空字符串。</li>
</ul>
<h3 id="42-stringprototypecharcodeat">4.2. String.prototype.charCodeAt()</h3>
<p><code>charCodeAt()</code>方法返回字符串指定位置的 <code>Unicode</code> 码点（十进制表示），相当于 <code>String.fromCharCode()</code>的逆操作。</p>
<pre class="hljs"><code><div><span class="hljs-string">"d"</span>.charCodeAt(<span class="hljs-number">0</span>); <span class="hljs-comment">// 100</span>
<span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">100</span>); <span class="hljs-comment">// "d"</span>
</div></code></pre>
<h3 id="43-stringprototypeconcat">4.3. String.prototype.concat()</h3>
<p><code>concat</code> 方法用于连接多个字符，返回一个新字符串，不改变原字符串。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">let</span> s11 = <span class="hljs-string">"qwe"</span>;
<span class="hljs-keyword">let</span> s12 = <span class="hljs-string">"asd"</span>;
<span class="hljs-keyword">let</span> s13 = s11.concat(s12);
s13; <span class="hljs-comment">// "qweasd";</span>
s11; <span class="hljs-comment">// "qwe"</span>

<span class="hljs-keyword">let</span> s14 = <span class="hljs-string">"zxc"</span>;
<span class="hljs-keyword">let</span> s15 = s14.concat(s12, s13);
s15; <span class="hljs-comment">// "zxcasdqweasd"</span>
</div></code></pre>
<p>如果参数不是字符串，<code>concat</code> 方法会将其先转为字符串，然后再连接。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> one = <span class="hljs-number">1</span>;
<span class="hljs-keyword">var</span> two = <span class="hljs-number">2</span>;
<span class="hljs-keyword">var</span> three = <span class="hljs-string">"3"</span>;

<span class="hljs-string">""</span>.concat(one, two, three); <span class="hljs-comment">// "123"</span>
one + two + three; <span class="hljs-comment">// "33"</span>
</div></code></pre>
<h3 id="44-stringprototypesearch">4.4. String.prototype.search()</h3>
<p><code>search()</code> 匹配字符串，返回匹配到的第一个位置。如果没有匹配到，返回 <code>-1</code>。类似于 <code>indexOf()</code>。</p>
<pre class="hljs"><code><div><span class="hljs-string">"dog,pig,monkey"</span>.search(<span class="hljs-string">"mo"</span>); <span class="hljs-comment">// 8</span>
<span class="hljs-string">"dog,pig,monkey"</span>.search(<span class="hljs-string">"money"</span>); <span class="hljs-comment">// -1</span>

<span class="hljs-string">"dog,pig,monkey"</span>.indexOf(<span class="hljs-string">"mo"</span>); <span class="hljs-comment">// 8</span>
<span class="hljs-string">"dog,pig,monkey"</span>.indexOf(<span class="hljs-string">"money"</span>); <span class="hljs-comment">// -1</span>
</div></code></pre>
<h3 id="45-stringprototypereplace">4.5. String.prototype.replace()</h3>
<p><code>replace</code> 方法用于替换匹配的子字符串，一般情况下只替换第一个匹配项。返回一个新的字符串，不改变原字符串。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">let</span> s = <span class="hljs-string">"aaa"</span>;
<span class="hljs-keyword">let</span> s1 = s.replace(<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>);
s; <span class="hljs-comment">// "aaa"</span>
s1; <span class="hljs-comment">// "baa"</span>
</div></code></pre>
<h3 id="46-stringprototypematch">4.6. String.prototype.match()</h3>
<pre class="hljs"><code><div>str.match(regexp);
</div></code></pre>
<p><code>match</code> 方法用于确定原字符串是否匹配某一个子字符串，返回一个数组。如果传入一个非正则表达式对象，则会隐式地使用 <code>new RegExp(obj)</code> 将其转换为一个 <code>RegExp</code> 。</p>
<p>返回值包括：</p>
<ul>
<li>匹配的成员。</li>
<li><code>groups</code>: 一个捕获组数组 或 undefined（如果没有定义命名捕获组）。</li>
<li><code>index</code>: 匹配的结果的开始位置。</li>
<li><code>input</code>: 搜索的字符串。</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">let</span> a = <span class="hljs-string">"cat, bat, sat, fat"</span>.match(<span class="hljs-string">"at"</span>);
a <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>; <span class="hljs-comment">// true</span>
a[<span class="hljs-number">0</span>]; <span class="hljs-comment">// "at"</span>
a[<span class="hljs-string">"index"</span>]; <span class="hljs-comment">// 1</span>
[<span class="hljs-string">"at"</span>, (index: <span class="hljs-number">1</span>), (input: <span class="hljs-string">"cat, bat, sat, fat"</span>), (groups: <span class="hljs-literal">undefined</span>)];
</div></code></pre>
<h3 id="47-stringprototypesplit">4.7. String.prototype.split()</h3>
<p><code>split</code> 方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。</p>
<pre class="hljs"><code><div><span class="hljs-string">"abc"</span>.split(<span class="hljs-string">"abc"</span>); <span class="hljs-comment">// ["", ""]</span>
<span class="hljs-string">"a|b|c"</span>.split(<span class="hljs-string">""</span>); <span class="hljs-comment">// ["a", "|", "b", "|", "c"]</span>
<span class="hljs-string">"a|b|c"</span>.split(); <span class="hljs-comment">// ["a|b|c"]</span>
<span class="hljs-string">"a||c"</span>.split(<span class="hljs-string">"|"</span>); <span class="hljs-comment">// ['a', '', 'c']</span>
<span class="hljs-string">"|b|c"</span>.split(<span class="hljs-string">"|"</span>); <span class="hljs-comment">// ["", "b", "c"]</span>
<span class="hljs-string">"a|b|"</span>.split(<span class="hljs-string">"|"</span>); <span class="hljs-comment">// ["a", "b", ""]</span>
</div></code></pre>
<p>从上面代码可以看出：</p>
<ul>
<li>如果分割的字符串和原字符串相同，则返回两个空字符串成员组成的数组。</li>
<li>如果分割的字符串是空字符串，则返回数组的成员是原字符串的每一个字符。</li>
<li>如果省略参数，则返回数组的唯一成员就是原字符串。</li>
<li>如果满足分割规则的两个部分紧邻着（即两个分割符中间没有其他字符），则返回数组之中会有一个空字符串。</li>
<li>如果满足分割规则的部分处于字符串的开头或结尾（即它的前面或后面没有其他字符），则返回数组的第一个或最后一个成员是一个空字符串。</li>
</ul>
<p><code>split</code> 方法还可以接受第二个参数，限定返回数组的最大成员数。</p>
<pre class="hljs"><code><div><span class="hljs-string">"a|b|c"</span>.split(<span class="hljs-string">"|"</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// []</span>
<span class="hljs-string">"a|b|c"</span>.split(<span class="hljs-string">"|"</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// ["a"]</span>
<span class="hljs-string">"a|b|c"</span>.split(<span class="hljs-string">"|"</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// ["a", "b"]</span>
<span class="hljs-string">"a|b|c"</span>.split(<span class="hljs-string">"|"</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// ["a", "b", "c"]</span>
<span class="hljs-string">"a|b|c"</span>.split(<span class="hljs-string">"|"</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// ["a", "b", "c"]</span>
</div></code></pre>
<h3 id="48-stringprototypetrim">4.8. String.prototype.trim()</h3>
<p><code>trim</code> 方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。</p>
<pre class="hljs"><code><div><span class="hljs-string">`   hello world  `</span>.trim(); <span class="hljs-comment">// "hello world"</span>
</div></code></pre>
<p>该方法去除的不仅仅是空格，还包括制表符（<code>\t</code>、<code>\v</code>）、换行符（<code>\n</code>）、回车符（<code>\r</code>）。</p>
<pre class="hljs"><code><div><span class="hljs-string">"\r\n\vabc \t"</span>.trim(); <span class="hljs-comment">// "abc"</span>

(<span class="hljs-string">"\n"</span>);
<span class="hljs-comment">// "</span>
<span class="hljs-comment">// "</span>

(<span class="hljs-string">"\t"</span>); <span class="hljs-comment">// "	"</span>
(<span class="hljs-string">"\v"</span>); <span class="hljs-comment">// ""</span>
</div></code></pre>
<h3 id="49-stringprototypetolowercase-%E5%92%8C-stringprototypetouppercase">4.9. String.prototype.toLowerCase() 和 String.prototype.toUpperCase()</h3>
<p><code>toLowerCase</code> 方法用于将一个字符串中字符全部转换为小写，<code>toUpperCase</code> 方法将一个字符串中字符全部转换为大写。返回新的字符串，不改变原字符。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">let</span> s = <span class="hljs-string">"Hello World"</span>;
<span class="hljs-keyword">let</span> sLower = s.toLowerCase();
sLower; <span class="hljs-comment">// "hello world"</span>
s; <span class="hljs-comment">// "Hello World"</span>

<span class="hljs-keyword">let</span> s1 = <span class="hljs-string">"Hello World"</span>;
<span class="hljs-keyword">let</span> s1Upper = s1.toUpperCase();
s1Upper; <span class="hljs-comment">// "HELLO WORLD"</span>
s1; <span class="hljs-comment">// "Hello World"</span>
</div></code></pre>
<h3 id="410-stringprototypelocalecompare">4.10. String.prototype.localeCompare()</h3>
<p><code>localeCompare</code> 方法用于比较两个字符串。它返回一个整数，如果小于 0，表示第一个字符串小于第二个字符串；如果等于 0，表示两者相等；如果大于 0，表示第一个字符串大于第二个字符串。</p>
<pre class="hljs"><code><div><span class="hljs-string">"dog"</span>.localeCompare(<span class="hljs-string">"dog"</span>); <span class="hljs-comment">// 0</span>
<span class="hljs-string">"apple"</span>.localeCompare(<span class="hljs-string">"banana"</span>); <span class="hljs-comment">// -1</span>
<span class="hljs-string">"e"</span>.localeCompare(<span class="hljs-string">"d"</span>); <span class="hljs-comment">// 1</span>
</div></code></pre>
<p>JavaScript 采用的是 Unicode 码点比较，直接通过比较运算符来比较两个字符时 <code>B</code> 小于 <code>a</code>。</p>
<pre class="hljs"><code><div><span class="hljs-string">"B"</span> &gt; <span class="hljs-string">"a"</span>; <span class="hljs-comment">// false</span>
</div></code></pre>
<p>而 <code>localeCompare</code> 方法会考虑自然语言的排序情况，<code>B</code> 排在 <code>a</code> 的前面。</p>
<pre class="hljs"><code><div><span class="hljs-string">"B"</span>.localeCompare(<span class="hljs-string">"a"</span>); <span class="hljs-comment">// 1</span>
</div></code></pre>
<h3 id="411-stringprototypesubstrstringprototypesubstring-%E5%92%8C-stringprototypeslice">4.11. String.prototype.substr()、String.prototype.substring() 和 String.prototype.slice()</h3>
<p><code>substr</code> 方法用于从原字符串取出子字符串并返回，不改变原字符串，跟 <code>slice</code> 和 <code>substring</code> 方法的作用相同。区别是：</p>
<p>4.11.1. 第二个参数的含义不同</p>
<ul>
<li><code>substr</code> 方法的<strong>第二个参数表示子字符串的长度</strong>。</li>
<li><code>substring</code> 方法的第二个参数表示子字符串的结束位置（不含该位置）。</li>
<li><code>slice</code> 方法的第二个参数表示子字符串的结束位置（不含该位置）。</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-string">"JavaScript"</span>.substr(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// "avaS"</span>
<span class="hljs-string">"Javascript"</span>.substring(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// "ava"</span>
<span class="hljs-string">"Javascript"</span>.slice(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// "ava"</span>
</div></code></pre>
<p>4.11.2. 对于参数为负的处理不同</p>
<ul>
<li><code>substr</code> 方法，如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，会被自动转换成 0，会返回空字符串。</li>
<li><code>substring</code> 方法，任何一个参数是负数将自动转换为 0.</li>
<li><code>slice</code> 方法，参数是负数表示从结尾开始倒数计算的位置，即该负数加上字符串长度。</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-string">"JavaScript"</span>.substr(<span class="hljs-number">2</span>, <span class="hljs-number">-2</span>); <span class="hljs-comment">// "", 第二个参数为负会被转换为 0，表示截取 0 个字符，于是返回为空。。</span>
<span class="hljs-string">"JavaScript"</span>.substr(<span class="hljs-number">-7</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// "aScr", 从倒数第 7 位开始取 4 位字符。</span>

<span class="hljs-string">"JavaScript"</span>.substring(<span class="hljs-number">-7</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// "Java", 第一个参数会被自动转换为 0，从 0 开始取到第 4 位（不包括第 4 位）。</span>
<span class="hljs-string">"JavaScript"</span>.substring(<span class="hljs-number">-7</span>, <span class="hljs-number">-4</span>); <span class="hljs-comment">// "", 两个参数会被自动转换为 0。</span>

<span class="hljs-string">"Javascript"</span>.slice(<span class="hljs-number">-5</span>, <span class="hljs-number">-4</span>); <span class="hljs-comment">// "c" , 表示从倒数第 5 位取到倒数第 4 位（不包括倒数第 4 位）。</span>
<span class="hljs-string">"Javascript"</span>.slice(<span class="hljs-number">-7</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// "a" , 表示从倒数第 7 位（10 - 7 = 3，第 3 位）取到倒数第 4 位（不包括倒数第 4 位）。</span>
</div></code></pre>
<p>4.11.3. 对于第一个参数大于第二个参数的处理不同</p>
<ul>
<li><code>substr</code> 方法，分别按照上面的规则处理第一个参数、第二个参数。</li>
<li><code>substring</code> 方法，如果第一个参数大于第二个参数，自动调换位置。</li>
<li><code>slice</code> 方法，如果第一个参数大于第二个参数，且同时为正或同时为负时，返回空字符串，其他情况参考前面的标准。</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-string">"JavaScript"</span>.substr(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// "aS", 从第 3 位截取两个字符。</span>
<span class="hljs-string">"JavaScript"</span>.substr(<span class="hljs-number">-3</span>, <span class="hljs-number">-5</span>); <span class="hljs-comment">// "", 如果第二个参数是负数，会被自动转换成 0，会返回空字符串。</span>

<span class="hljs-string">"JavaScript"</span>.substring(<span class="hljs-number">1</span>, <span class="hljs-number">-4</span>); <span class="hljs-comment">// "J", 第一个参数大于第二个参数，相互调换位置，第一个参数为负转换为 0，表示从 0  位取到第 1 位（不包括第一位）</span>
<span class="hljs-string">"JavaScript"</span>.substring(<span class="hljs-number">-5</span>, <span class="hljs-number">-6</span>); <span class="hljs-comment">// "“， 任何一个参数为负都被转换为 0。</span>

<span class="hljs-string">"JavaScript"</span>.slice(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// "", 返回空字符串。</span>
<span class="hljs-string">"JavaScript"</span>.slice(<span class="hljs-number">-3</span>, <span class="hljs-number">-4</span>); <span class="hljs-comment">// ""，返回空字符串。</span>
<span class="hljs-string">"JavaScript"</span>.slice(<span class="hljs-number">3</span>, <span class="hljs-number">-4</span>); <span class="hljs-comment">// "aSc"，从第 3 位截取到第 （10 - 4 = 6） 位（不包括第6位）。</span>
</div></code></pre>
<h3 id="412-stringprototypeindexof-%E5%92%8C-stringprototypelastindexof">4.12. String.prototype.indexOf() 和 String.prototype.lastIndexOf()</h3>
<p><code>indexOf</code> 方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回 -1，就表示不匹配。</p>
<pre class="hljs"><code><div><span class="hljs-string">"hello world"</span>.indexOf(<span class="hljs-string">"o"</span>); <span class="hljs-comment">// 4</span>
<span class="hljs-string">"JavaScript"</span>.indexOf(<span class="hljs-string">"script"</span>); <span class="hljs-comment">// -1</span>
</div></code></pre>
<p><code>indexOf</code> 方法还可以接受第二个参数，表示从该位置开始向后匹配。</p>
<pre class="hljs"><code><div><span class="hljs-string">"hello world"</span>.indexOf(<span class="hljs-string">"o"</span>, <span class="hljs-number">6</span>); <span class="hljs-comment">// 7</span>
</div></code></pre>
<p><code>lastIndexOf</code> 方法的用法跟 <code>indexOf</code> 方法一致，主要的区别是 <code>lastIndexOf</code> <code>从尾部开始匹配，indexOf</code> 则是从头部开始匹配。</p>
<pre class="hljs"><code><div><span class="hljs-string">"hello world"</span>.lastIndexOf(<span class="hljs-string">"o"</span>); <span class="hljs-comment">// 7, 从最后一个字符开始向前匹配， 第一次匹配到 'o'，是 "world" 中的 'o'，所在的位置是 7</span>
</div></code></pre>
<p>另外，<code>lastIndexOf</code> 的第二个参数表示从该位置起向前匹配。</p>
<pre class="hljs"><code><div><span class="hljs-string">"hello world"</span>.lastIndexOf(<span class="hljs-string">"o"</span>, <span class="hljs-number">6</span>); <span class="hljs-comment">// 4，从第 6 个字符（'w'）开始向前匹配，第 1 次匹配到 'o' 是 "hello" 中的 'o'，所在的位置是 7</span>
<span class="hljs-string">"hello world"</span>.lastIndexOf(<span class="hljs-string">"o"</span>, <span class="hljs-number">7</span>); <span class="hljs-comment">// 7，从第 7 个字符（'o'）开始向前匹配，第 1 次匹配到 'o' 是 "world" 中的 'o'，所在的位置是 7</span>
</div></code></pre>

</body>
</html>
